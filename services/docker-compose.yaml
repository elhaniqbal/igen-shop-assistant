services:
  # ---- Combined Frontend + Nginx ----
  frontend:
    build:
      context: ./ui
      dockerfile: Dockerfile.frontend
    restart: unless-stopped # change in production
    ports:
      - "8080:8080"
    environment:
      - VITE_MQTT_URL=${VITE_MQTT_URL}
      - NODE_ENV=${NODE_ENV}
    depends_on:
      backend:
        condition: service_started
    networks:
      - internal
      - public

  # ---- Backend (FastAPI) ----
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile.backend
    restart: no # change in production
    expose:
      - "8000"
    ports:
      - "5000:8000"
    environment:
      - DATABASE_URL=${DATABASE_URL}
      - MQTT_BROKER=mqtt # if inside docker mqtt, localhost otherwise
      - MQTT_PORT=1883
      - PYTHONUNBUFFERED=1
    volumes:
      - ./data:/app/data       # âœ… Persistent SQLite storage
    healthcheck:
      disable: true # remove for PROD
    depends_on:
      sqlite-web2:
        condition: service_started
      mqtt:
        condition: service_started
      mqttx:
        condition: service_started
      bridge:
        condition: service_started
     
    networks:
      - internal

  sqlite-web2:
    build:
      context: ./db
      dockerfile: Dockerfile.sqlite-web
    restart: unless-stopped
    ports:
      - "8083:8080"
    environment:
      - SQLITE_DATABASE=${SQLITE_PATH}
    volumes:
      - ./data:/data
    networks:
      - internal
      - public

  # ---- Mosquitto MQTT Broker ----
  mqtt:
    image: eclipse-mosquitto:2
    restart: unless-stopped
    ports:
      - "1883:1883"
      - "9001:9001"
    volumes:
      - ./mosquitto/config:/mosquitto/config
      - mosquitto_data:/mosquitto/data
      - mosquitto_log:/mosquitto/log
    networks:
      - internal

  # ---- MQTTX Web GUI ----
  mqttx:
    image: emqx/mqttx-web
    restart: unless-stopped
    ports:
      - "8090:80"
    environment:
      - TZ=UTC
    networks:
      - internal
      - public
    depends_on:
      - mqtt

  # ---- Bridge Sidecar (MQTT <-> Serial) ----
  bridge:
    build:
      context: ./backend
      dockerfile: Dockerfile.bridge
    restart: unless-stopped
    environment:
      - MQTT_HOST=mqtt
      - MQTT_PORT=1883
      - BRIDGE_MODE=SIM          # switch to SERIAL on Raspberry Pi
      - SERIAL_PORT=/dev/ttyUSB0 # used only in SERIAL mode
      - SERIAL_BAUD=115200
      - ACK_TIMEOUT_MS=500
      - DONE_TIMEOUT_MS=30000
      - SIM_FAIL_RATE=0.08
      - SIM_MIN_TIME_S=0.4
      - SIM_MAX_TIME_S=1.5
      - SIM_ACK_DELAY_S=0.05
    depends_on:
      mqtt:
        condition: service_started
    networks:
      - internal
    # For Raspberry Pi SERIAL mode, uncomment:
    # devices:
    #   - "/dev/ttyUSB0:/dev/ttyUSB0"

  # ---- RFID Sidecar (MFRC522 -> MQTT) ----
  # rfid:
  #   build:
  #     context: ./backend
  #     dockerfile: Dockerfile.rfid
  #   restart: unless-stopped
  #   environment:
  #     - MQTT_HOST=mqtt
  #     - MQTT_PORT=1883
  #     - RFID_READER_ID=kiosk_1_reader_1
  #     - RFID_DEFAULT_MODE=card
  #     - RFID_UID_ONLY=1
  #     - RFID_POLL_DELAY_S=0.05
  #   depends_on:
  #     mqtt:
  #       condition: service_started
  #   networks:
  #     - internal
    # IMPORTANT:
    # - On Windows dev, this container may fail if it requires Raspberry Pi GPIO/SPI libs.
    #   If so, either comment out this service locally or add a SIM mode to rfid script.
    #
    # For Raspberry Pi with real MFRC522 over SPI/GPIO, uncomment:
    # privileged: true
    # devices:
    #   - "/dev/spidev0.0:/dev/spidev0.0"
    #   - "/dev/spidev0.1:/dev/spidev0.1"
    #   - "/dev/gpiomem:/dev/gpiomem"

networks:
  internal:
    driver: bridge
  public:
    driver: bridge

volumes:
  mosquitto_data:
  mosquitto_log:
