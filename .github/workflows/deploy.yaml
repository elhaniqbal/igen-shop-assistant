name: Deploy Stack on Raspberry Pi (Local Build)

on:
  workflow_dispatch:

concurrency:
  group: deploy-pi
  cancel-in-progress: true

jobs:
  deploy:
    name: Local Build & Deploy
    runs-on: [ self-hosted, linux, arm64 ]
    timeout-minutes: 30

    env:
      WORKDIR: ${{ github.workspace }}/services
      FRONTEND_PORT: 8080
      SQLITE_PORT: 8083
      MQTTX_PORT: 8090
      HEALTH_PATH: /api/healthz
      # content lives in YAML, written to services/.env
      DEFAULT_ENV: |
        # -------- Defaults for Pi (can be edited on the device) --------
        APP_ENV=pi
        DATABASE_URL=sqlite:////app/data/local_cache.db

        # MQTT
        MQTT_BROKER=mqtt
        MQTT_PORT=1883
        MQTT_TOPIC=rfid/scan

        # Kiosk UI (nginx)
        EDGE_HTTP_PORT=8080
        NODE_ENV=development

        # Frontend expects these; nginx proxies /api to backend
        VITE_API_URL=http://backend:8000
        VITE_MQTT_URL=ws://localhost:8080/mqtt
        SQLITE_PATH=/data/local_cache.db

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Environment diagnostics
        run: |
          echo "‚úÖ Hostname: $(hostname)"
          echo "üèóÔ∏è Architecture: $(uname -m)"
          echo "üê≥ Docker version: $(docker --version)"
          echo "üì¶ Compose version: $(docker compose version)"
          echo "üìÅ Workdir: $PWD"
          echo "üë§ Runner user: $(id -u):$(id -g)"
          echo "üîê docker.sock perms: $(ls -l /var/run/docker.sock || true)"
          groups

      - name: Ensure services/.env exists with sane defaults
        shell: bash
        run: |
          if [[ ! -f services/.env ]]; then
            mkdir -p services
            printf '%s' "$DEFAULT_ENV" > services/.env
            echo "Created services/.env"
          else
            echo "services/.env exists; leaving as-is"
          fi
          echo "--- services/.env (redacted) ---"
          sed 's/=.*/=***redacted***/' services/.env

      - name: Stop previous containers
        working-directory: ${{ env.WORKDIR }}
        run: |
          echo "üßπ Cleaning up old containers/images..."
          docker compose down --remove-orphans || true
          docker image prune -f || true

      - name: Start Docker containers
        working-directory: ${{ env.WORKDIR }}
        run: |
          echo "üöÄ Starting services..."
          docker compose up -d
          docker compose ps

      - name: Wait for frontend->backend health
        run: |
          echo "üîç Waiting for health at http://127.0.0.1:${{ env.FRONTEND_PORT }}${{ env.HEALTH_PATH }}"
          for i in {1..50}; do
            sleep 2
            if curl -fs "http://127.0.0.1:${{ env.FRONTEND_PORT }}${{ env.HEALTH_PATH }}" >/dev/null; then
              echo "‚úÖ Healthy."
              exit 0
            fi
            echo "Attempt $i..."
          done
          echo "‚ùå Health check failed. Dumping logs."
          cd "${{ env.WORKDIR }}" && sudo -E docker compose logs --no-color || true
          exit 1

      - name: Quick route check (/api/ping)
        run: |
          curl -fs "http://127.0.0.1:${{ env.FRONTEND_PORT }}/api/ping" | grep -q pong \
            && echo "‚úÖ /api/ping OK" \
            || (echo "‚ùå /api/ping failed" && exit 1)

      - name: Tail backend logs (last 100 lines)
        working-directory: ${{ env.WORKDIR }}
        run: sudo -E docker compose logs --tail=100 backend || true

      - name: Ensure Tailscale service running
        run: |
          if ! systemctl is-active --quiet tailscaled; then
            echo "üîÑ Starting Tailscale service..."
            sudo systemctl enable --now tailscaled
          fi
          echo "‚úÖ Tailscale service status:"
          sudo systemctl status tailscaled --no-pager || true
          tailscale status || true

      - name: Configure Tailscale Serve (Frontend, SQLite, MQTTX)
        run: |
          echo "üîß Configuring Tailscale Serve..."
          sudo tailscale serve --https=443 http://127.0.0.1:${{ env.FRONTEND_PORT }} || true
          sudo tailscale serve --set-path /sqlite http://127.0.0.1:${{ env.SQLITE_PORT }} || true
          sudo tailscale serve --set-path /mqttx http://127.0.0.1:${{ env.MQTTX_PORT }} || true
          sudo tailscale funnel 443 on || true
          echo "‚úÖ Tailscale Serve routes:"
          tailscale serve status || true

      - name: Deployment summary
        run: |
          LAN_IP=$(hostname -I | awk '{print $1}')
          echo "---------------------------------------------"
          echo "‚úÖ Deployment success"
          echo ""
          echo "üåç Tailscale public URLs (via Funnel):"
          tailscale serve status || true
          echo "---------------------------------------------"
