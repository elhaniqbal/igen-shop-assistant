name: Deploy Stack on Raspberry Pi (Local Build)

on:
  push:
    branches: [ "main" ]
    
  workflow_dispatch:

concurrency:
  group: deploy-pi
  cancel-in-progress: true

jobs:
  deploy:
    name: Local Build & Deploy
    runs-on: [ self-hosted, linux, arm64 ]
    timeout-minutes: 30

    env:
      WORKDIR: ${{ github.workspace }}
      FRONTEND_PORT: 8080
      SQLITE_PORT: 8082
      MQTTX_PORT: 8090
      HEALTH_PATH: /api/healthz
      APP_ENV: pi
      DATABASE_URL: sqlite:////app/data/local_cache.db
      MQTT_BROKER: mqtt
      MQTT_PORT: 1883
      MQTT_TOPIC: rfid/scan
      EDGE_HTTP_PORT: 8080
      NODE_ENV: development
      VITE_API_URL: http://backend:8000
      VITE_MQTT_URL: ws://localhost:8080/mqtt
      SQLITE_PATH: /data/local_cache.db

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Environment diagnostics
        run: |
          echo "‚úÖ Hostname: $(hostname)"
          echo "üèóÔ∏è Architecture: $(uname -m)"
          echo "üê≥ Docker version: $(docker --version)"
          echo "üì¶ Compose version: $(docker compose version)"
          echo "üìÅ Workdir: $PWD"
          echo "üë§ Runner user: $(id -u):$(id -g)"

      # Ensure a default .env exists (idempotent)
      - name: Ensure services/.env exists with sane defaults
        shell: bash
        run: |
          if [[ ! -f services/.env ]]; then
            mkdir -p services
            printf '%s' "$DEFAULT_ENV" > services/.env
            echo "Created services/.env"
          else
            echo "services/.env exists; leaving as-is"
          fi
          echo "--- services/.env (redacted) ---"
          sed 's/=.*/=***redacted***/' services/.env

      - name: Stop previous containers
        run: |
          echo "üßπ Cleaning up old containers/images..."
          docker compose down --remove-orphans || true
          docker image prune -f || true

      - name: Build all Docker images locally (ARM64)
        run: |
          echo "üèóÔ∏è Building stack images..."
          docker compose build --pull --force-rm
          echo "‚úÖ Build complete."

      - name: Start stack
        run: |
          echo "üöÄ Starting services..."
          docker compose up -d
          docker compose ps

      - name: Wait for frontend->backend health
        run: |
          echo "üîç Waiting for health at http://127.0.0.1:${{ env.FRONTEND_PORT }}${{ env.HEALTH_PATH }}"
          for i in {1..50}; do
            sleep 2
            if curl -fs "http://127.0.0.1:${{ env.FRONTEND_PORT }}${{ env.HEALTH_PATH }}" >/dev/null; then
              echo "‚úÖ Healthy."
              exit 0
            fi
            echo "Attempt $i..."
          done
          echo "‚ùå Health check failed. Dumping logs."
          docker compose logs --no-color
          exit 1

      - name: Quick route check (/api/ping)
        run: |
          curl -fs "http://127.0.0.1:${{ env.FRONTEND_PORT }}/api/ping" | grep -q pong \
            && echo "‚úÖ /api/ping OK" \
            || (echo "‚ùå /api/ping failed" && exit 1)

      - name: Tail backend logs (last 100 lines)
        run: docker compose logs --tail=100 backend || true
      
        # üü¢ Tailscale: assume it's already installed & logged in
      - name: Ensure Tailscale service running
        run: |
          if ! systemctl is-active --quiet tailscaled; then
            echo "üîÑ Starting Tailscale service..."
            sudo systemctl enable --now tailscaled
          fi
          echo "‚úÖ Tailscale service status:"
          sudo systemctl status tailscaled --no-pager || true
          tailscale status || true

      # Expose all web UIs via Tailscale Serve/Funnel
      - name: Configure Tailscale Serve (Frontend, SQLite, MQTTX)
        run: |
          echo "üîß Configuring Tailscale Serve..."
          sudo tailscale serve --https=443 http://localhost:${{ env.FRONTEND_PORT }} || true
          sudo tailscale serve /sqlite http://localhost:${{ env.SQLITE_PORT }} || true
          sudo tailscale serve /mqttx http://localhost:${{ env.MQTTX_PORT }} || true
          sudo tailscale funnel 443 on || true
          echo "‚úÖ Tailscale Serve routes:"
          tailscale serve status || true

      - name: Deployment summary
        run: |
          LAN_IP=$(hostname -I | awk '{print $1}')
          echo "---------------------------------------------"
          echo "‚úÖ Deployment success"
          echo "LAN:        http://$LAN_IP:${{ env.FRONTEND_PORT }}"
          echo "Local:      http://127.0.0.1:${{ env.FRONTEND_PORT }}"
          echo ""
          echo "üåç Tailscale public URLs (via Funnel):"
          tailscale serve status || true
          echo "---------------------------------------------"
